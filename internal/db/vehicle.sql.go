// Code generated by sqlc. DO NOT EDIT.
// source: vehicle.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const deleteVehiclePrice = `-- name: DeleteVehiclePrice :exec
update vehicle_price
set deleted_at = now()
where id = $1
`

func (q *Queries) DeleteVehiclePrice(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVehiclePrice, id)
	return err
}

const detailVehicle = `-- name: DetailVehicle :one
select id::uuid,
       type_id::uuid,
       type_name::varchar,
       model::varchar,
       brand::varchar,
       category_id::uuid,
       category_name::varchar,
       range::integer,
       wheels::float,
       max_load::integer,
       top_speed::integer,
       waterproof::integer,
       weight::integer,
       images::json,
       prices::json,
       created_at::timestamp,
       updated_at::timestamp
from detail_vehicle($1::uuid)
`

type DetailVehicleRow struct {
	ID           uuid.UUID   `json:"id"`
	TypeID       uuid.UUID   `json:"type_id"`
	TypeName     string      `json:"type_name"`
	Model        string      `json:"model"`
	Brand        string      `json:"brand"`
	CategoryID   uuid.UUID   `json:"category_id"`
	CategoryName string      `json:"category_name"`
	Range        int32       `json:"range"`
	Wheels       float64     `json:"wheels"`
	MaxLoad      int32       `json:"max_load"`
	TopSpeed     int32       `json:"top_speed"`
	Waterproof   int32       `json:"waterproof"`
	Weight       int32       `json:"weight"`
	Images       pgtype.JSON `json:"images"`
	Prices       pgtype.JSON `json:"prices"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
}

func (q *Queries) DetailVehicle(ctx context.Context, id uuid.UUID) (DetailVehicleRow, error) {
	row := q.db.QueryRow(ctx, detailVehicle, id)
	var i DetailVehicleRow
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.TypeName,
		&i.Model,
		&i.Brand,
		&i.CategoryID,
		&i.CategoryName,
		&i.Range,
		&i.Wheels,
		&i.MaxLoad,
		&i.TopSpeed,
		&i.Waterproof,
		&i.Weight,
		&i.Images,
		&i.Prices,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fetchVehicle = `-- name: FetchVehicle :many
select id::uuid,
       model::varchar,
       brand::varchar,
       images::json,
       lowest_price::bigint
from fetch_vehicle()
limit $1 offset $2
`

type FetchVehicleParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type FetchVehicleRow struct {
	ID          uuid.UUID   `json:"id"`
	Model       string      `json:"model"`
	Brand       string      `json:"brand"`
	Images      pgtype.JSON `json:"images"`
	LowestPrice int64       `json:"lowest_price"`
}

func (q *Queries) FetchVehicle(ctx context.Context, arg FetchVehicleParams) ([]FetchVehicleRow, error) {
	rows, err := q.db.Query(ctx, fetchVehicle, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchVehicleRow{}
	for rows.Next() {
		var i FetchVehicleRow
		if err := rows.Scan(
			&i.ID,
			&i.Model,
			&i.Brand,
			&i.Images,
			&i.LowestPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchVehicleCategory = `-- name: FetchVehicleCategory :many
select id, name
from vehicle_category
where deleted_at is null
`

type FetchVehicleCategoryRow struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) FetchVehicleCategory(ctx context.Context) ([]FetchVehicleCategoryRow, error) {
	rows, err := q.db.Query(ctx, fetchVehicleCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchVehicleCategoryRow{}
	for rows.Next() {
		var i FetchVehicleCategoryRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchVehicleType = `-- name: FetchVehicleType :many
select id, name
from vehicle_type
where deleted_at is null
`

type FetchVehicleTypeRow struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) FetchVehicleType(ctx context.Context) ([]FetchVehicleTypeRow, error) {
	rows, err := q.db.Query(ctx, fetchVehicleType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchVehicleTypeRow{}
	for rows.Next() {
		var i FetchVehicleTypeRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const storeVehicle = `-- name: StoreVehicle :exec
insert into vehicle(type_id, model, brand, category_id, range, wheels, max_load, top_speed, waterproof, weight)
VALUES ($1::uuid, $2::varchar, $3::varchar, $4::uuid, $5::int, $6::float,
        $7::int, $8::int, $9::int, $10::int)
`

type StoreVehicleParams struct {
	TypeID     uuid.UUID `json:"type_id"`
	Model      string    `json:"model"`
	Brand      string    `json:"brand"`
	CategoryID uuid.UUID `json:"category_id"`
	Range      int32     `json:"range"`
	Wheels     float64   `json:"wheels"`
	MaxLoad    int32     `json:"max_load"`
	TopSpeed   int32     `json:"top_speed"`
	Waterproof int32     `json:"waterproof"`
	Weight     int32     `json:"weight"`
}

func (q *Queries) StoreVehicle(ctx context.Context, arg StoreVehicleParams) error {
	_, err := q.db.Exec(ctx, storeVehicle,
		arg.TypeID,
		arg.Model,
		arg.Brand,
		arg.CategoryID,
		arg.Range,
		arg.Wheels,
		arg.MaxLoad,
		arg.TopSpeed,
		arg.Waterproof,
		arg.Weight,
	)
	return err
}

const storeVehicleImage = `-- name: StoreVehicleImage :exec
insert into vehicle_image (file, dir, vehicle_id)
values ($1::varchar, $2::varchar, $3::uuid)
`

type StoreVehicleImageParams struct {
	File      string    `json:"file"`
	Dir       string    `json:"dir"`
	VehicleID uuid.UUID `json:"vehicle_id"`
}

func (q *Queries) StoreVehicleImage(ctx context.Context, arg StoreVehicleImageParams) error {
	_, err := q.db.Exec(ctx, storeVehicleImage, arg.File, arg.Dir, arg.VehicleID)
	return err
}

const updateVehicle = `-- name: UpdateVehicle :exec
update vehicle
set type_id       = (case
                         when $1::uuid = '00000000-0000-0000-0000-000000000000' then type_id
                         else $1::uuid end),
    model         = (case when $2::varchar = '' then model else $2::varchar end),
    brand         = (case when $3::varchar = '' then brand else $3::varchar end),
    category_id   = (case
                         when $4::uuid = '00000000-0000-0000-0000-000000000000' then category_id
                         else $4::uuid end),
    range         = (case when $5::int = 0 then range else $5::int end),
    wheels        = (case when $6::float = 0 then wheels else $6::float end),
    max_load      = (case when $7::int = 0 then max_load else $7::int end),
    top_speed     = (case when $8::int = 0 then top_speed else $8::int end),
    waterproof    = (case when $9::int = 0 then waterproof else $9::int end),
    weight        = (case when $10::int = 0 then weight else $10::int end),
    plat_number   = (case when $11::varchar = '' then plat_number else $11::varchar end),
    frame_number  = (case when $12::varchar = '' then frame_number else $12::varchar end),
    engine_number = (case when $13::varchar = '' then engine_number else $13::varchar end),
    updated_at    = now()
where id = $14::uuid
`

type UpdateVehicleParams struct {
	TypeID       uuid.UUID `json:"type_id"`
	Model        string    `json:"model"`
	Brand        string    `json:"brand"`
	CategoryID   uuid.UUID `json:"category_id"`
	Range        int32     `json:"range"`
	Wheels       float64   `json:"wheels"`
	MaxLoad      int32     `json:"max_load"`
	TopSpeed     int32     `json:"top_speed"`
	Waterproof   int32     `json:"waterproof"`
	Weight       int32     `json:"weight"`
	PlatNumber   string    `json:"plat_number"`
	FrameNumber  string    `json:"frame_number"`
	EngineNumber string    `json:"engine_number"`
	ID           uuid.UUID `json:"id"`
}

func (q *Queries) UpdateVehicle(ctx context.Context, arg UpdateVehicleParams) error {
	_, err := q.db.Exec(ctx, updateVehicle,
		arg.TypeID,
		arg.Model,
		arg.Brand,
		arg.CategoryID,
		arg.Range,
		arg.Wheels,
		arg.MaxLoad,
		arg.TopSpeed,
		arg.Waterproof,
		arg.Weight,
		arg.PlatNumber,
		arg.FrameNumber,
		arg.EngineNumber,
		arg.ID,
	)
	return err
}

const upsertVehiclePrice = `-- name: UpsertVehiclePrice :exec
insert into vehicle_price(vehicle_id, duration, duration_type_id, price)
values ($1::uuid, $2::int, $3::uuid, $4::bigint)
on conflict(vehicle_id,duration,duration_type_id) DO UPDATE
    SET duration   = $2::int,
        price      = $4::bigint,
        updated_at = now(),
        deleted_at = null
`

type UpsertVehiclePriceParams struct {
	VehicleID      uuid.UUID `json:"vehicle_id"`
	Duration       int32     `json:"duration"`
	DurationTypeID uuid.UUID `json:"duration_type_id"`
	Price          int64     `json:"price"`
}

func (q *Queries) UpsertVehiclePrice(ctx context.Context, arg UpsertVehiclePriceParams) error {
	_, err := q.db.Exec(ctx, upsertVehiclePrice,
		arg.VehicleID,
		arg.Duration,
		arg.DurationTypeID,
		arg.Price,
	)
	return err
}

const validateVehicle = `-- name: ValidateVehicle :one
select result::varchar
from validate_vehicle($1::uuid, $2::uuid, $3::uuid, $4::uuid)
`

type ValidateVehicleParams struct {
	TypeID         uuid.UUID `json:"type_id"`
	CategoryID     uuid.UUID `json:"category_id"`
	VehicleID      uuid.UUID `json:"vehicle_id"`
	DurationTypeID uuid.UUID `json:"duration_type_id"`
}

func (q *Queries) ValidateVehicle(ctx context.Context, arg ValidateVehicleParams) (string, error) {
	row := q.db.QueryRow(ctx, validateVehicle,
		arg.TypeID,
		arg.CategoryID,
		arg.VehicleID,
		arg.DurationTypeID,
	)
	var result string
	err := row.Scan(&result)
	return result, err
}
